<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ° èŒè¶£ä¸­è‹±æ–‡å¬å†™åŠ©æ‰‹ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Microsoft YaHei", "å¹¼åœ†", sans-serif;
            max-width: 800px; margin: 15px auto; text-align: center;
            background: linear-gradient(135deg, #fdf6f8 0%, #e9f5ff 100%); padding: 15px;
        }
        .header {
            background: #fff; border-radius: 20px; padding: 18px; margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(255, 182, 193, 0.2); border: 2px solid #ffd1dc;
        }
        .header h1 {
            color: #ff6b9d; font-size: 1.8rem; margin-bottom: 8px;
            display: flex; align-items: center; justify-content: center; gap: 12px;
        }
        .header h1 span { font-size: 2rem; }
        .header p { color: #6a994e; font-size: 0.95rem; font-weight: 500; }
        .main-area {
            background: #fff; border-radius: 25px; padding: 25px 15px; margin: 18px 0;
            box-shadow: 0 6px 15px rgba(173, 216, 230, 0.3); border: 3px solid #bde0fe;
        }
        .unit-label {
            font-size: 1.2rem; color: #4a7c59; margin-bottom: 12px; font-weight: bold;
            background: #f1faee; display: inline-block; padding: 5px 15px; border-radius: 30px;
        }
        .word-display {
            font-size: 2.2rem; font-weight: bold; color: #264653; margin: 20px 0; padding: 20px;
            background: #f8f9fa; border-radius: 15px; border: 2px dashed #ffc8dd;
            min-height: 120px; display: flex; align-items: center; justify-content: center;
            line-height: 1.5;
        }
        .timer {
            font-size: 2.2rem; color: #ff758f; margin: 12px 0; font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,117,143,0.2);
        }
        .control-btn {
            padding: 10px 25px; font-size: 1rem; margin: 6px; border: none; border-radius: 30px;
            cursor: pointer; color: white; font-weight: 500; transition: all 0.3s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .start-btn { background: #ff9a8b; }
        .start-btn:hover { background: #ff6b6b; transform: translateY(-2px); }
        .reset-btn { background: #74c69d; }
        .reset-btn:hover { background: #52b788; transform: translateY(-2px); }
        .switch-btn { background: #7b66ff; }
        .switch-btn:hover { background: #6344ff; transform: translateY(-2px); }
        .language-btn { background: #9d4edd; }
        .language-btn:hover { background: #7b2cbf; transform: translateY(-2px); }
        .func-area {
            margin: 20px 0; padding: 20px; background: #fff; border-radius: 20px;
            box-shadow: 0 4px 12px rgba(255, 218, 185, 0.25); border: 2px solid #fefae0;
        }
        .area-title {
            font-size: 1.3rem; color: #264653; margin-bottom: 15px; font-weight: bold;
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .upload-area .area-title { color: #e76f51; }
        .check-area .area-title { color: #2a9d8f; }
        .func-btn {
            padding: 9px 22px; font-size: 1rem; margin: 6px; border: none; border-radius: 30px;
            cursor: pointer; color: white; font-weight: 500; transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .upload-area .func-btn { background: #f4a261; }
        .upload-area .func-btn:hover { background: #e9c46a; transform: scale(1.03); }
        .upload-area .func-btn.album-btn { background: #38b000; }
        .upload-area .func-btn.album-btn:hover { background: #2d9100; }
        .check-area .func-btn { background: #264653; }
        .check-area .func-btn:hover { background: #2a9d8f; transform: scale(1.03); }
        .check-area .func-btn.album-btn { background: #38b000; }
        .check-area .func-btn.album-btn:hover { background: #2d9100; }
        .func-btn:disabled {
            background: #d1d1d1; cursor: not-allowed; transform: none;
        }
        .photo-preview {
            max-width: 280px; height: auto; margin: 10px auto;
            border: 3px dashed #ffd6a5; border-radius: 12px; display: none;
            padding: 5px;
        }
        .file-input { display: none; }
        .result-area {
            margin-top: 18px; text-align: left; max-height: 280px; overflow-y: auto;
            padding: 15px; background: #f9f9f9; border-radius: 12px; border: 2px solid #e9ecef;
            font-size: 0.95rem; line-height: 1.6;
        }
        .correct { color: #27ae60; font-weight: bold; }
        .wrong { color: #e74c3c; font-weight: bold; }
        .accuracy {
            font-size: 1rem; margin-top: 12px; color: #264653; font-weight: bold;
            background: #f1faee; padding: 8px 12px; border-radius: 8px;
        }
        .word-list-tip {
            color: #e76f51; font-size: 0.9rem; margin-top: 10px; padding: 8px 12px;
            background: #fff3e6; border-radius: 8px; display: inline-block; max-width: 90%;
        }
        .tip {
            color: #6c757d; font-size: 0.9rem; margin: 15px 0; line-height: 1.6;
            background: #f8f9fa; padding: 10px; border-radius: 12px; border: 1px solid #e9ecef;
        }
        .loading { color: #7b66ff; font-weight: bold; }
        .debug-info {
            background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px;
            font-family: monospace; font-size: 0.8rem; text-align: left;
            max-height: 100px; overflow-y: auto; display: none;
        }
        .voice-status {
            color: #6a994e; font-size: 0.85rem; margin-top: 5px;
            padding: 5px 10px; background: #f1faee; border-radius: 8px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span>ğŸ°</span> èŒè¶£ä¸­è‹±æ–‡å¬å†™åŠ©æ‰‹ï¼ˆä¼˜åŒ–ç‰ˆï¼‰<span>ğŸ±</span></h1>
        <p>ğŸŒŸ æ™ºèƒ½è§£ææ–‡æœ¬ï½œç²¾å‡†ä¸­è‹±æ–‡è¯†åˆ«ï½œæ”¯æŒæ‹ç…§ä¸ç›¸å†Œä¸Šä¼ ï½œè¯­éŸ³ä¼˜åŒ–</p>
        <p class="voice-status" id="voiceStatus">è¯­éŸ³ç³»ç»ŸåŠ è½½ä¸­...</p>
    </div>

    <div class="main-area">
        <div class="unit-label" id="unitLabel">å½“å‰ï¼šé»˜è®¤çŸ­è¯­å¬å†™</div>
        <div class="word-display" id="wordDisplay">å‡†å¤‡å¼€å§‹å¬å†™å•¦ï½</div>
        <div class="timer" id="timer">6</div>
        <button id="languageToggleBtn" class="control-btn language-btn">ğŸ”Š æŠ¥è¯»æ¨¡å¼ï¼šè‹±æ–‡</button>
        <button id="startBtn" class="control-btn start-btn">ğŸˆ å¼€å§‹å¬å†™</button>
        <button id="resetBtn" class="control-btn reset-btn">ğŸ”„ é‡ç½®</button>
        <button id="switchUnitBtn" class="control-btn switch-btn">ğŸ”– åˆ‡æ¢é»˜è®¤çŸ­è¯­</button>
    </div>

    <div class="func-area upload-area">
        <div class="area-title">ğŸ“š ä¸Šä¼ /é€‰æ‹©çŸ­è¯­è¡¨å›¾ç‰‡ï¼ˆæ”¯æŒä¸­è‹±æ–‡ï¼‰</div>
        <input type="file" accept="image/*" capture="environment" class="file-input" id="wordFileInput">
        <input type="file" accept="image/*" class="file-input" id="chooseWordFileInput">
        <button id="uploadWordBtn" class="func-btn">ğŸ“¸ æ‹ç…§ä¸Šä¼ çŸ­è¯­è¡¨</button>
        <button id="chooseWordBtn" class="func-btn album-btn">ğŸ–¼ï¸ ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡</button>
        <button id="confirmWordBtn" class="func-btn" disabled>âœ… ç¡®è®¤å¯¼å…¥çŸ­è¯­</button>
        <img id="uploadPreview" class="photo-preview" alt="çŸ­è¯­ç…§ç‰‡é¢„è§ˆ">
        <div class="debug-info" id="debugInfo"></div>
        <p class="word-list-tip" id="extractedWordTip">ç­‰å¾…æå–çŸ­è¯­ï½</p>
    </div>

    <div class="func-area check-area">
        <div class="area-title">âœï¸ ä¸Šä¼ /é€‰æ‹©æˆ‘çš„é»˜å†™çº¸</div>
        <input type="file" accept="image/*" capture="environment" class="file-input" id="checkFileInput">
        <input type="file" accept="image/*" class="file-input" id="chooseCheckFileInput">
        <button id="takePhotoBtn" class="func-btn">ğŸ“· æ‹ç…§ä¸Šä¼ é»˜å†™çº¸</button>
        <button id="chooseCheckBtn" class="func-btn album-btn">ğŸ–¼ï¸ ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡</button>
        <button id="checkBtn" class="func-btn" disabled>ğŸŒŸ å¼€å§‹æ‰¹æ”¹æ‰“åˆ†</button>
        <img id="checkPreview" class="photo-preview" alt="æ‰¹æ”¹ç…§ç‰‡é¢„è§ˆ">
        <div class="result-area" id="correctResult"></div>
    </div>

    <p class="tip">ğŸ’¡ ä½¿ç”¨å°æç¤ºï¼š<br>
        1. <b>ä¸¤ç§ä¸Šä¼ æ–¹å¼</b>ï¼šæ¯ä¸ªåŠŸèƒ½åŒºéƒ½æœ‰ã€æ‹ç…§ä¸Šä¼ ã€‘å’Œã€ä»ç›¸å†Œé€‰æ‹©ã€‘æŒ‰é’®ï¼Œå…ˆç”¨æ‰«æAppå¤„ç†å›¾ç‰‡å†ä¸Šä¼ ï¼Œè¯†åˆ«æ•ˆæœæ›´ä½³ï¼<br>
        2. <b>æ™ºèƒ½æ–‡æœ¬è§£æ</b>ï¼šç³»ç»Ÿä¼šè‡ªåŠ¨æŒ‰åºå·ï¼ˆ1. 2. 3.ï¼‰åˆ†å‰²å†…å®¹ï¼Œå¹¶è¿‡æ»¤ä¹±ç ã€‚<br>
        3. <b>æŠ¥è¯»æ¨¡å¼</b>ï¼šç‚¹å‡»ä¸Šæ–¹ç´«è‰²æŒ‰é’®ï¼Œå¯åœ¨ã€Œä¸­æ–‡ã€å’Œã€Œè‹±æ–‡ã€æœ—è¯»é—´åˆ‡æ¢ï¼Œæœ—è¯»æ—¶ä¼šè‡ªåŠ¨è¿‡æ»¤è¯æ€§ç­‰æ— å…³ä¿¡æ¯ã€‚<br>
        4. <b>è¯­éŸ³ä¼˜åŒ–</b>ï¼šç³»ç»Ÿå·²ä¼˜åŒ–ä¸­è‹±æ–‡è¯­éŸ³åˆæˆï¼Œä¸­æ–‡æœ—è¯»æ›´è¿è´¯è‡ªç„¶ã€‚<br>
        5. <b>æ‹ç…§è¦ç‚¹</b>ï¼šå…‰çº¿å……è¶³ã€å¯¹å‡†ç„¦ã€å­—è¿¹æ¸…æ™°ã€‚</p>

    <script>
        // ========== åŸºç¡€æ•°æ® ==========
        const unit1 = [
            "buy pretty clothes", "need a new coat", "a long zip",
            "some lovely buttons", "a useful pocket", "the blouse with buttons",
            "the jacket with a zip", "the sweater with pockets", "put on her shoes",
            "take off the gloves"
        ];
        const unit2 = [
            "wear a dress", "a pair of jeans", "a warm scarf",
            "a comfortable hat", "tie your shoelaces", "a colorful skirt",
            "a soft sweater", "a stylish shirt", "put on your socks",
            "take off your hat"
        ];

        // ========== æ ¸å¿ƒå˜é‡ ==========
        let speechLanguage = 'en-US';
        let currentLanguageMode = 'è‹±æ–‡';
        let currentUnit = unit1;
        let customWordList = [];
        let isCustomMode = false;
        let currentWordIndex = 0;
        let timerInterval = null;
        let timeLeft = 6;
        let isRunning = false;
        let uploadPhotoData = null;
        let checkPhotoData = null;
        let availableVoices = [];

        const unit1Pure = unit1.map(w => w.toLowerCase().replace(/[^a-z]/g, ''));
        const unit2Pure = unit2.map(w => w.toLowerCase().replace(/[^a-z]/g, ''));
        let currentPureList = unit1Pure;

        // ========== DOM å…ƒç´  ==========
        const el = id => document.getElementById(id);
        const wordDisplay = el('wordDisplay'), timerDisplay = el('timer'), startBtn = el('startBtn');
        const resetBtn = el('resetBtn'), switchUnitBtn = el('switchUnitBtn'), unitLabel = el('unitLabel');
        const uploadWordBtn = el('uploadWordBtn'), confirmWordBtn = el('confirmWordBtn'), uploadPreview = el('uploadPreview');
        const extractedWordTip = el('extractedWordTip'), takePhotoBtn = el('takePhotoBtn'), checkBtn = el('checkBtn');
        const checkPreview = el('checkPreview'), correctResult = el('correctResult');
        const wordFileInput = el('wordFileInput'), checkFileInput = el('checkFileInput');
        const languageToggleBtn = el('languageToggleBtn'), debugInfo = el('debugInfo');
        const chooseWordBtn = el('chooseWordBtn'), chooseWordFileInput = el('chooseWordFileInput');
        const chooseCheckBtn = el('chooseCheckBtn'), chooseCheckFileInput = el('chooseCheckFileInput');
        const voiceStatus = el('voiceStatus');

        // ========== è¯­éŸ³åˆå§‹åŒ– ==========
        function initSpeechSynthesis() {
            // åŠ è½½å¯ç”¨çš„è¯­éŸ³
            const loadVoices = () => {
                availableVoices = window.speechSynthesis.getVoices();
                if (availableVoices.length > 0) {
                    const chineseVoices = availableVoices.filter(v => v.lang === 'zh-CN' || v.lang === 'zh-TW');
                    const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
                    
                    voiceStatus.innerHTML = `âœ… è¯­éŸ³ç³»ç»Ÿå·²å°±ç»ª<br>ä¸­æ–‡è¯­éŸ³: ${chineseVoices.length}ä¸ª | è‹±æ–‡è¯­éŸ³: ${englishVoices.length}ä¸ª`;
                    
                    // æ§åˆ¶å°è¾“å‡ºå¯ç”¨è¯­éŸ³ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    console.log('å¯ç”¨è¯­éŸ³åˆ—è¡¨:');
                    availableVoices.forEach(v => console.log(`- ${v.name} (${v.lang})`));
                } else {
                    voiceStatus.textContent = 'âš ï¸ æœªæ£€æµ‹åˆ°è¯­éŸ³å¼•æ“ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™';
                }
            };
            
            // ç«‹å³å°è¯•åŠ è½½
            loadVoices();
            
            // ç›‘å¬è¯­éŸ³åˆ—è¡¨å˜åŒ–
            window.speechSynthesis.onvoiceschanged = loadVoices;
            
            // è®¾ç½®è¶…æ—¶æ£€æŸ¥
            setTimeout(loadVoices, 1000);
        }

        // ========== ã€æ ¸å¿ƒã€‘æ–‡æœ¬æ™ºèƒ½è§£æä¸æ¸…æ´—å‡½æ•° ==========
        /**
         * æ ¸å¿ƒè§£æå‡½æ•°ï¼šä¸“é—¨å¤„ç†ä¸­è‹±æ–‡æ··åˆæ–‡æœ¬
         */
        function parseRecognitionText(text) {
            let results = [];
            // æ›¿æ¢å¸¸è§çš„OCRé”™è¯¯
            text = text.replace(/\*\*[A-Z]+\*\*\./g, '')
                       .replace(/RERET\./g, '')
                       .replace(/\s+/g, ' ');
            
            // æ–¹æ³•1ï¼šæŒ‰åºå·æ¨¡å¼åˆ†å‰²
            const itemPattern = /(\d+[\.\)\ã€]\s*)(.*?)(?=\s*\d+[\.\)\ã€]|$)/gs;
            let match;
            
            while ((match = itemPattern.exec(text + '\n999.')) !== null) {
                let item = match[2].trim();
                if (item) {
                    item = cleanRecognitionItem(item);
                    if (item.length > 5) {
                        results.push(item);
                    }
                }
            }
            
            // æ–¹æ³•2ï¼šå¦‚æœä¸Šé¢å¤±è´¥ï¼ŒæŒ‰è¡Œå¤„ç†
            if (results.length === 0) {
                const lines = text.split('\n');
                let currentItem = '';
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    if (!line) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯åºå·è¡Œ
                    const isNumberedLine = /^\d+[\.\)\ã€]/.test(line);
                    
                    if (isNumberedLine) {
                        // ä¿å­˜ä¸Šä¸€ä¸ª
                        if (currentItem) {
                            currentItem = cleanRecognitionItem(currentItem);
                            if (currentItem.length > 5) results.push(currentItem);
                        }
                        // å¼€å§‹æ–°çš„
                        currentItem = line.replace(/^\d+[\.\)\ã€]\s*/, '');
                    } else {
                        // ç»­æ¥è¡Œ
                        if (currentItem) {
                            currentItem += ' ' + line;
                        } else {
                            currentItem = line;
                        }
                    }
                }
                
                // æœ€åä¸€ä¸ª
                if (currentItem) {
                    currentItem = cleanRecognitionItem(currentItem);
                    if (currentItem.length > 5) results.push(currentItem);
                }
            }
            
            return results;
        }

        /**
         * ä¼˜åŒ–åçš„æ¸…æ´—å‡½æ•°ï¼šä¿ç•™å®Œæ•´çš„ä¸­è‹±æ–‡å¥å­
         */
        function cleanRecognitionItem(item) {
            if (!item) return '';
            
            let cleaned = item;
            
            // 1. ç§»é™¤OCRå¸¸è§çš„é”™è¯¯å­—ç¬¦å’Œä¹±ç 
            cleaned = cleaned.replace(/\*\*[A-Z]+\*\*\./g, '');  // ç§»é™¤ **RERET.** è¿™ç±»ä¹±ç 
            cleaned = cleaned.replace(/[|\\<>\[\]{}]/g, '');
            
            // 2. ä¿®å¤ä¸­æ–‡å­—ç¬¦é—´çš„ç©ºæ ¼ï¼ˆä¸­æ–‡ä¹‹é—´ä¸åº”è¯¥æœ‰ç©ºæ ¼ï¼‰
            cleaned = cleaned.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
            
            // 3. ä¿®å¤è‹±æ–‡æ ‡ç‚¹å‰çš„ç©ºæ ¼é—®é¢˜
            cleaned = cleaned.replace(/\s+([.,?!;:])/g, '$1');
            cleaned = cleaned.replace(/([a-zA-Z])\s+([.,?!;:])/g, '$1$2');
            
            // 4. ç¡®ä¿ä¸­è‹±æ–‡ä¹‹é—´æœ‰ä¸€ä¸ªç©ºæ ¼
            cleaned = cleaned.replace(/([\u4e00-\u9fa5])([a-zA-Z])/g, '$1 $2');
            cleaned = cleaned.replace(/([a-zA-Z])([\u4e00-\u9fa5])/g, '$1 $2');
            
            // 5. å‹ç¼©å¤šä½™çš„ç©ºæ ¼
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            
            // 6. ä¿®å¤å¸¸è§çš„OCRè¯†åˆ«é”™è¯¯
            const corrections = {
                'ç©¿è¿‡è¿›æ¥': 'ç©¿è¿‡ç…§è¿›æ¥',
                'ç©¿è¿‡æ¥': 'ç©¿è¿‡ç…§è¿›æ¥',
                'éœ€20åˆ†é’Ÿ': 'åªéœ€20åˆ†é’Ÿ',
                'éœ€ 20 åˆ†é’Ÿ': 'åªéœ€20åˆ†é’Ÿ',
                // æ·»åŠ å…¶ä»–å¸¸è§é”™è¯¯ä¿®æ­£
            };
            
            Object.keys(corrections).forEach(wrong => {
                const correct = corrections[wrong];
                cleaned = cleaned.replace(new RegExp(wrong, 'g'), correct);
            });
            
            return cleaned;
        }

        /**
         * é¢„å¤„ç†ä¸­æ–‡æ–‡æœ¬ï¼Œä½¿å…¶æœ—è¯»æ›´è‡ªç„¶
         */
        function preprocessChineseText(text) {
            let processed = text;
            
            // 1. å°†æ•°å­—è½¬æ¢ä¸ºä¸­æ–‡è¯»æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
            processed = processed.replace(/(\d+)/g, match => {
                const num = parseInt(match);
                if (num >= 0 && num <= 10) {
                    const chineseNumbers = ['é›¶', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å'];
                    return chineseNumbers[num] || match;
                }
                return match;
            });
            
            // 2. å¤„ç†å¸¸è§æ ‡ç‚¹
            processed = processed.replace(/\./g, 'ã€‚');
            processed = processed.replace(/\?/g, 'ï¼Ÿ');
            processed = processed.replace(/!/g, 'ï¼');
            processed = processed.replace(/,/g, 'ï¼Œ');
            
            // 3. ç§»é™¤ä¸å¿…è¦çš„ç©ºæ ¼ï¼ˆä¸­æ–‡ä¸éœ€è¦å•è¯é—´çš„ç©ºæ ¼ï¼‰
            processed = processed.replace(/\s+/g, '');
            
            return processed;
        }

        /**
         * æ¸…æ´—æœ—è¯»æ–‡æœ¬ï¼šåªå»é™¤åºå·ï¼Œä¿ç•™å®Œæ•´å¥å­
         */
        function cleanTextForSpeech(text) {
            if (!text) return '';
            
            let cleaned = text.trim();
            
            // ç§»é™¤åºå·
            cleaned = cleaned.replace(/^\d+[\.\)\ã€]\s*/, '');
            
            if (speechLanguage === 'zh-CN') {
                // æå–ä¸­æ–‡éƒ¨åˆ†
                const chineseMatch = cleaned.match(/[\u4e00-\u9fa5][^a-zA-Z]*/g);
                if (chineseMatch && chineseMatch.length > 0) {
                    // åˆå¹¶æ‰€æœ‰ä¸­æ–‡éƒ¨åˆ†å¹¶é¢„å¤„ç†
                    const chineseText = chineseMatch.join('').trim();
                    return preprocessChineseText(chineseText);
                }
            } else {
                // æå–è‹±æ–‡éƒ¨åˆ†
                const englishMatch = cleaned.match(/[a-zA-Z][^[\u4e00-\u9fa5]]*/g);
                if (englishMatch && englishMatch.length > 0) {
                    // åˆå¹¶æ‰€æœ‰è‹±æ–‡éƒ¨åˆ†
                    return englishMatch.join(' ').trim();
                }
            }
            
            return cleaned;
        }

        // ========== è¯­éŸ³ä¸è®¡æ—¶åŠŸèƒ½ ==========
        function readWordThreeTimes(wordText) {
            const rawPhrase = wordText.trim();
            const cleanedPhrase = cleanTextForSpeech(rawPhrase);
            window.speechSynthesis.cancel();
            
            // ä¸‰æ¬¡æœ—è¯»ï¼Œé—´éš”1ç§’
            setTimeout(() => speakWord(cleanedPhrase), 0);
            setTimeout(() => speakWord(cleanedPhrase), 1000);
            setTimeout(() => speakWord(cleanedPhrase), 2000);
        }

        function speakWord(word) {
            if (!word) return;
            
            const speech = new SpeechSynthesisUtterance(word);
            speech.lang = speechLanguage;
            speech.volume = 1;
            
            // æ ¹æ®ä¸åŒè¯­è¨€è°ƒæ•´å‚æ•°
            if (speechLanguage === 'zh-CN') {
                // ä¸­æ–‡ä¼˜åŒ–å‚æ•°
                speech.rate = 0.8;  // ç¨å¾®å¿«ä¸€ç‚¹
                speech.pitch = 1.0;  // æ­£å¸¸éŸ³é«˜
                
                // é€‰æ‹©ä¸­æ–‡è¯­éŸ³
                const chineseVoice = availableVoices.find(v => 
                    v.lang === 'zh-CN' || v.lang === 'zh-TW' || v.lang === 'zh-HK'
                );
                if (chineseVoice) {
                    speech.voice = chineseVoice;
                    speech.rate = 0.85; // ä¸­æ–‡è¯­éŸ³é€šå¸¸å¯ä»¥å¿«ä¸€ç‚¹
                }
            } else {
                // è‹±æ–‡ä¼˜åŒ–å‚æ•°
                speech.rate = 0.6;  // æ…¢ä¸€ç‚¹æ›´æ¸…æ™°
                speech.pitch = 1.0;
                
                // é€‰æ‹©è‹±æ–‡è¯­éŸ³
                const englishVoice = availableVoices.find(v => 
                    v.lang.startsWith('en-') || v.lang === 'en'
                );
                if (englishVoice) {
                    speech.voice = englishVoice;
                }
            }
            
            // è®¾ç½®æ–‡æœ¬
            speech.text = word;
            
            // å¼€å§‹æœ—è¯»
            window.speechSynthesis.speak(speech);
        }

        function startTimer() {
            timeLeft = 6; 
            timerDisplay.textContent = timeLeft;
            
            timerInterval = setInterval(() => {
                timeLeft--; 
                timerDisplay.textContent = timeLeft;
                
                if (timeLeft <= 0) { 
                    clearInterval(timerInterval); 
                    nextWord(); 
                }
            }, 1000);
        }

        function nextWord() {
            currentWordIndex++;
            
            if (currentWordIndex < currentUnit.length) {
                const phrase = currentUnit[currentWordIndex];
                wordDisplay.textContent = phrase;
                readWordThreeTimes(phrase);
                startTimer();
            } else {
                wordDisplay.textContent = "ğŸ‰ å¬å†™å…¨éƒ¨å®Œæˆå•¦ï¼";
                timerDisplay.textContent = "0";
                isRunning = false;
                startBtn.disabled = false;
                confirmWordBtn.disabled = false;
            }
        }

        // ========== äº¤äº’äº‹ä»¶ç›‘å¬ ==========
        // 1. è¯­è¨€åˆ‡æ¢
        languageToggleBtn.addEventListener('click', function() {
            if (speechLanguage === 'en-US') {
                speechLanguage = 'zh-CN';
                currentLanguageMode = 'ä¸­æ–‡';
                this.textContent = 'ğŸ”Š æŠ¥è¯»æ¨¡å¼ï¼šä¸­æ–‡';
                this.style.background = '#ffaa00';
            } else {
                speechLanguage = 'en-US';
                currentLanguageMode = 'è‹±æ–‡';
                this.textContent = 'ğŸ”Š æŠ¥è¯»æ¨¡å¼ï¼šè‹±æ–‡';
                this.style.background = '#9d4edd';
            }
        });

        // 2. ä¸Šä¼ å¹¶è¯†åˆ«çŸ­è¯­è¡¨å›¾ç‰‡ (æ‹ç…§)
        uploadWordBtn.addEventListener('click', () => wordFileInput.click());
        wordFileInput.addEventListener('change', handleWordImageFile);

        // 3. ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡ (çŸ­è¯­è¡¨)
        chooseWordBtn.addEventListener('click', () => chooseWordFileInput.click());
        chooseWordFileInput.addEventListener('change', handleWordImageFile);

        // é€šç”¨çš„çŸ­è¯­å›¾ç‰‡å¤„ç†å‡½æ•°
        async function handleWordImageFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                uploadPhotoData = e.target.result;
                uploadPreview.src = uploadPhotoData;
                uploadPreview.style.display = 'block';
                extractedWordTip.textContent = 'â³ æ­£åœ¨è¯†åˆ«å›¾ç‰‡ä¸­çš„çŸ­è¯­...';
                extractedWordTip.classList.add('loading');
                confirmWordBtn.disabled = true;
            };
            reader.readAsDataURL(file);

            try {
                const { data: { text } } = await Tesseract.recognize(file, 'eng+chi_sim', {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            extractedWordTip.textContent = `â³ è¯†åˆ«è¿›åº¦: ${Math.round(m.progress * 100)}%`;
                        }
                    },
                    // ä¼˜åŒ–OCRé…ç½®
                    tessedit_pageseg_mode: '3',  // 3 = è‡ªåŠ¨åˆ†å‰²
                    tessedit_ocr_engine_mode: '1',  // ä½¿ç”¨LSTMå¼•æ“ï¼ˆå¯¹ä¸­æ–‡æ›´å¥½ï¼‰
                    preserve_interword_spaces: '1',  // ä¿æŒå•è¯é—´è·
                    user_defined_dpi: '300',  // æé«˜DPI
                    textord_min_linesize: '2.0',  // æœ€å°è¡Œå°ºå¯¸
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,?!;:\'"()[]{}- \u4e00-\u9fa5ï¼Œã€‚ï¼›ï¼šï¼Ÿï¼ã€ï¼ˆï¼‰ã€ã€‘ã€Šã€‹ã€Œã€'
                });
                
                // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                debugInfo.textContent = 'OCRåŸå§‹ç»“æœ:\n' + text;
                debugInfo.style.display = 'block';
                
                customWordList = parseRecognitionText(text);
                customWordList = [...new Set(customWordList)];

                if (customWordList.length > 0) {
                    extractedWordTip.innerHTML = `âœ¨ æå–æˆåŠŸï¼å…± <strong>${customWordList.length}</strong> æ¡å†…å®¹ã€‚<br>ç¤ºä¾‹ï¼š${customWordList.slice(0, 3).map((item, idx) => `<br>${idx+1}. ${item}`).join('')}`;
                    extractedWordTip.classList.remove('loading');
                    confirmWordBtn.disabled = false;
                } else {
                    extractedWordTip.textContent = 'ğŸ˜¥ æ²¡æœ‰è¯†åˆ«åˆ°æœ‰æ•ˆæ–‡æœ¬ï¼Œè¯·æ¢ä¸€å¼ æ›´æ¸…æ™°çš„å›¾ç‰‡è¯•è¯•å§ï½';
                    extractedWordTip.classList.remove('loading');
                    confirmWordBtn.disabled = true;
                }
            } catch (err) {
                console.error('OCR Error:', err);
                extractedWordTip.textContent = 'ğŸ˜¥ è¯†åˆ«å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–å›¾ç‰‡ã€‚';
                extractedWordTip.classList.remove('loading');
                confirmWordBtn.disabled = true;
            }
        }

        // 4. ç¡®è®¤å¯¼å…¥è‡ªå®šä¹‰çŸ­è¯­
        confirmWordBtn.addEventListener('click', () => {
            if (customWordList.length === 0) return;
            
            isCustomMode = true;
            currentUnit = customWordList;
            currentPureList = customWordList.map(w => w.toLowerCase().replace(/[^a-z\u4e00-\u9fa5]/g, ''));
            unitLabel.textContent = `å½“å‰ï¼šè‡ªå®šä¹‰åˆ—è¡¨ï¼ˆå…±${customWordList.length}æ¡ï¼‰`;
            resetBtn.click();
            
            // æ˜¾ç¤ºå¯¼å…¥æˆåŠŸæç¤º
            extractedWordTip.innerHTML = `âœ… å·²æˆåŠŸå¯¼å…¥${customWordList.length}æ¡å†…å®¹ï¼`;
            setTimeout(() => {
                alert('ğŸŠ è‡ªå®šä¹‰å†…å®¹å¯¼å…¥æˆåŠŸï¼ç‚¹å‡»ã€å¼€å§‹å¬å†™ã€‘å°±èƒ½ä½¿ç”¨å•¦ï½');
            }, 300);
        });

        // 5. ä¸Šä¼ é»˜å†™çº¸å›¾ç‰‡ (æ‹ç…§)
        takePhotoBtn.addEventListener('click', () => checkFileInput.click());
        checkFileInput.addEventListener('change', handleCheckImageFile);

        // 6. ä»ç›¸å†Œé€‰æ‹©å›¾ç‰‡ (é»˜å†™çº¸)
        chooseCheckBtn.addEventListener('click', () => chooseCheckFileInput.click());
        chooseCheckFileInput.addEventListener('change', handleCheckImageFile);

        // é€šç”¨çš„é»˜å†™å›¾ç‰‡å¤„ç†å‡½æ•°
        async function handleCheckImageFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                checkPhotoData = e.target.result;
                checkPreview.src = checkPhotoData;
                checkPreview.style.display = 'block';
                checkBtn.disabled = false;
                correctResult.innerHTML = '<p class="loading">ğŸ–¼ï¸ å›¾ç‰‡å·²ä¸Šä¼ ï¼Œç‚¹å‡»ã€å¼€å§‹æ‰¹æ”¹æ‰“åˆ†ã€‘è¿›è¡Œåˆ†æ...</p>';
            };
            reader.readAsDataURL(file);
        }

        // 7. æ‰¹æ”¹åŠŸèƒ½
        checkBtn.addEventListener('click', async () => {
            if (!checkPhotoData) { 
                alert('è¯·å…ˆä¸Šä¼ é»˜å†™çº¸å›¾ç‰‡å“¦ï½'); 
                return; 
            }
            if (currentPureList.length === 0) { 
                alert('è¯·å…ˆå¼€å§‹å¬å†™æˆ–å¯¼å…¥çŸ­è¯­åˆ—è¡¨ï½'); 
                return; 
            }

            try {
                correctResult.innerHTML = '<p class="loading">ğŸ” æ­£åœ¨æ‰¹æ”¹ï¼Œè¯·ç¨å€™...</p>';
                const fileInput = checkFileInput.files[0] ? checkFileInput : chooseCheckFileInput;
                const file = fileInput.files[0];
                const { data: { text } } = await Tesseract.recognize(file, 'eng+chi_sim', { 
                    tessedit_pageseg_mode: '3',
                    preserve_interword_spaces: '1'
                });
                
                const handWords = parseRecognitionText(text);

                let correctCount = 0;
                let resultHtml = '';
                const checkCount = Math.min(currentPureList.length, handWords.length);
                
                for (let i = 0; i < checkCount; i++) {
                    const stdPhrase = currentUnit[i];
                    const handPhrase = handWords[i] || '<span style="color:#999">æœªå¡«å†™</span>';
                    
                    // ç®€åŒ–çš„åŒ¹é…é€»è¾‘ï¼šå»é™¤ç©ºæ ¼å’Œæ ‡ç‚¹åæ¯”è¾ƒ
                    const stdClean = stdPhrase.toLowerCase().replace(/[^a-z\u4e00-\u9fa5]/g, '');
                    const handClean = handPhrase.toLowerCase().replace(/[^a-z\u4e00-\u9fa5]/g, '');
                    
                    const isCorrect = isCustomMode ? false : (stdClean === handClean);
                    if (isCorrect) correctCount++;
                    
                    resultHtml += `ç¬¬${i+1}é¢˜ï¼šæ ‡å‡†ã€${stdPhrase}ã€‘ â†’ ä½ çš„ã€${handPhrase}ã€‘ `;
                    
                    if(isCustomMode) {
                        resultHtml += `<span>ï¼ˆè‡ªå®šä¹‰å†…å®¹ï¼‰</span><br>`;
                    } else {
                        resultHtml += `<span class="${isCorrect?'correct':'wrong'}">${isCorrect?'âœ… æ­£ç¡®':'âŒ é”™è¯¯'}</span><br>`;
                    }
                    resultHtml += '<br>';
                }

                let accuracyMsg = '';
                if(isCustomMode && customWordList.some(item => /[\u4e00-\u9fa5]/.test(item))) {
                    accuracyMsg = `ğŸ“ å…± ${currentPureList.length} æ¡å†…å®¹ï¼Œå·²æ˜¾ç¤ºä½ çš„å¬å†™ç»“æœã€‚`;
                } else {
                    const accuracy = checkCount > 0 ? Math.round((correctCount / checkCount) * 100) : 0;
                    accuracyMsg = `ğŸ† æ‰¹æ”¹ç»“æœï¼šå…± ${checkCount} é¢˜ï¼Œç­”å¯¹ ${correctCount} é¢˜ï¼Œæ­£ç¡®ç‡ ${accuracy}%ï¼`;
                }
                
                resultHtml += `<div class="accuracy">${accuracyMsg}</div>`;
                correctResult.innerHTML = resultHtml;
            } catch (err) {
                console.error('Check Error:', err);
                correctResult.innerHTML = '<p class="wrong">ğŸ˜¥ è¯†åˆ«å¤±è´¥ï¼Œè¯·ç¡®ä¿å›¾ç‰‡æ¸…æ™°ã€å…‰çº¿å……è¶³ã€‚</p>';
            }
        });

        // 8. å¼€å§‹å¬å†™
        startBtn.addEventListener('click', () => {
            if (!isRunning && currentUnit.length > 0) {
                isRunning = true;
                startBtn.disabled = true;
                confirmWordBtn.disabled = true;
                currentWordIndex = 0;
                const firstPhrase = currentUnit[currentWordIndex];
                wordDisplay.textContent = firstPhrase;
                readWordThreeTimes(firstPhrase);
                startTimer();
            }
        });

        // 9. é‡ç½®
        resetBtn.addEventListener('click', () => {
            clearInterval(timerInterval);
            window.speechSynthesis.cancel();
            isRunning = false;
            currentWordIndex = 0;
            timeLeft = 6;
            wordDisplay.textContent = "å‡†å¤‡å¼€å§‹å¬å†™å•¦ï½";
            timerDisplay.textContent = "6";
            startBtn.disabled = false;
            confirmWordBtn.disabled = customWordList.length === 0;
        });

        // 10. åˆ‡æ¢é»˜è®¤å•å…ƒ
        switchUnitBtn.addEventListener('click', () => {
            isCustomMode = false;
            currentUnit = currentUnit === unit1 ? unit2 : unit1;
            currentPureList = currentUnit === unit1 ? unit1Pure : unit2Pure;
            unitLabel.textContent = currentUnit === unit1 ? 'å½“å‰ï¼šæœè£…çŸ­è¯­å¬å†™' : 'å½“å‰ï¼šå¤‡ç”¨çŸ­è¯­å¬å†™';
            resetBtn.click();
            uploadPreview.style.display = 'none';
            checkPreview.style.display = 'none';
            correctResult.innerHTML = '';
            extractedWordTip.textContent = 'ç­‰å¾…æå–çŸ­è¯­ï½';
            wordFileInput.value = '';
            checkFileInput.value = '';
            chooseWordFileInput.value = '';
            chooseCheckFileInput.value = '';
            uploadPhotoData = null;
            checkPhotoData = null;
            confirmWordBtn.disabled = true;
            checkBtn.disabled = true;
            debugInfo.style.display = 'none';
        });

        // ========== é¡µé¢åˆå§‹åŒ– ==========
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–è¯­éŸ³ç³»ç»Ÿ
            initSpeechSynthesis();
            
            // æ˜¾ç¤ºå½“å‰è¯­éŸ³çŠ¶æ€
            setTimeout(() => {
                if (availableVoices.length === 0) {
                    voiceStatus.textContent = 'âš ï¸ è¯­éŸ³ç³»ç»Ÿæœªå®Œå…¨åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢æˆ–æ£€æŸ¥æµè§ˆå™¨è®¾ç½®';
                }
            }, 2000);
            
            console.log('å¬å†™åŠ©æ‰‹å·²åˆå§‹åŒ–å®Œæˆï¼');
        });
    </script>
</body>
</html>